# [Platinum V] 버블 소트 - 1517 

[문제 링크](https://www.acmicpc.net/problem/1517) 

### 성능 요약

메모리: 16308 KB, 시간: 216 ms

### 분류

자료 구조(data_structures), 분할 정복(divide_and_conquer), 세그먼트 트리(segtree), 정렬(sorting)

### 문제 설명

<p>N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.</p>

<p>버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 들어있다.</p>

### 출력 

 <p>첫째 줄에 Swap 횟수를 출력한다</p>

### 노트

1. 분할정복 풀이

 문제에서 나온 말을 곧이곧대로 믿고 그냥 버블 정렬를 수행하면서 swap 횟수를 세면 O(N^2)이 걸린다.

 이 문제의 핵심 아이디어는 병합 정렬을 하면서 **swap이 일어나야 하는 횟수만 세면 결국 총 swap 횟수는 동일하다**는 것이다.

 divide(s, e) 함수와 merge( divide(s, mid), divide(mid+1, e) )  함수를 각각 구현하여 분할정복으로 병합정렬 함수를 구현하는 것은 쉽다.


>  *주의!*
> 
>  (1) 같은 숫자 끼리는 swap하지 않는다.  if( arr1[p1] <= arr2[p2] ) 조건문에 부등호 쓸 때 등호까지 포함해야함!
> 
>  (2) swap되는 횟수를 어떻게 세어야 하는가? merge 함수 내에 cnt += (arr1.size() - p1) 로 swap 횟수를 카운트하자.
>  arr1.size()에서 p1을 빼야 arr2[p2]가 들어갈 자리를 구할 수 있다.



-----


2. 구간합 세그트리 풀이

 터보소트 문제에서의 풀이와 마찬가지로 입력받은 숫자에 해당하는 인덱스를 저장해 둔 후, sum(0, index[n]) 까지의 구간합을 구해 사이에 있는 **n 보다 크고, 아직 정렬되지 않은 값** 들의 개수를 셀 수 있다. 

 트리의 리프 노드는 1로 초기화 하고, 작은 값 n 부터 배열에서 제거하며 swap 횟수를 카운트한다.


>  *주의!*
>  
>  (1) 역시 같은 숫자끼리는 swap하지 않는다.
> 
>  (2) 인덱스 배열을 index(N)으로 선언한 후, index[n] = i 식으로 {n : n에 해당하는 인덱스} 를 집어넣으면 세그폴트 에러를 당할 수 밖에 없다. 
> 
>  N = 5
> 
>  [7 4 5 1 3]
>  의 예제처럼 N보다 큰 입력값도 있기 때문.
> 
>  위의 두 문제를 한방에 해결해줄 해결책으로 pair<value, index> 를 담을 수 있는 배열 index(N)을 선언한 후,
>  (a) value를 기준으로 오름차순 정렬
>  (b) value가 같다면 index를 기준으로 오름차순 정렬 하면 된다.
> 
>  value를 기준으로 오름차순 정렬 했기에 작은 값부터 탐색을 시작할 것이며, 
>  value가 같다면 index가 가장 작은 것 부터 탐색하기에
> 
>  N = 3
> 
>  [5 5 5]
>  처럼 value가 같고 index가 더 큰 값들은 sum에서 무시될 것이다.(0으로 더해질 것이다.)
