배열의 각 위치에서 시작했을 때, 시작점보다 뒤쪽을 보며 시작점보다 더 큰 값과 작은 값을 찾자.
​
[5, 1, 3, 4, 2]
만약 2에서 시작한다면,
2에서는 higher jump도 lower jump도 둘 다 할 수 있다. 왜냐하면 이미 끝에 있기 때문.
higher(2) = true
lower(2) = true
​
만약 4에서 시작한다면,
4보다 뒤쪽에 더 큰 값이 없으므로 higher jump는 할 수 없다. higher(4) = false
4에서 2로 lower jump는 할 수 있고, 거기에 이어서 2에서 끝으로 higher jump도 할 수 있으므로 lower(4) = higher(2) = true
​
만약 3에서 시작한다면,
3보다 뒤쪽에 4가 있으므로, higher(3) = lower(4) = true
3보다 뒤쪽에 2가 있으므로, lower(3) = higher(2) = true
​
만약 1에서 시작한다면,
1보다 뒤쪽에 2가 있으므로, higher(1) = lower(2) = true
1보다 뒤쪽에 더 작은 값이 없으므로, lower(1) = false
​
만약 5에서 시작한다면,
5보다 뒤쪽에 더 큰 값이 없으므로, higher(5) = false
5보다 뒤쪽에 4가 있으므로, lower(5) = higher(4) = false
​
결국 매 시작점에서 시작점보다 뒤쪽의 배열을 바라보며, '시작점보다 큰 값 중 가장 작은 값'과 '시작점보다 작은 값 중 가장 큰 값'을 찾아내야 한다.
이를 위해서는 내부의 값이 단조 증가하는 모노톤 스택을 직접 구현해 쓰던가, 값을 저장하면 자동으로 정렬되는 map을 써서 binary search로 위에서 말한 '적당한 값' 들을 찾아내야 한다. 물론 이 '적당한 값'을 찾는 binary search 함수들도 lower_bound과 upper_bound로 이미 존재한다.
​
map을 이용해 실제로 구현을 할 때에는 단순히 element A[i]만 생각하는 것이 아닌 index i도 함께 고려해야 함을 주의하자. map<int, int> {A[i], i} 꼴로 저장하게 되면 map은 A[i]의 크기에 따라 오름차순 정렬을 하게 된다. 그러나 A[i]를 쓰는 이유는 단순히 '적당한 값'을 찾기 위함이고, 실제로는 '적당한 값'이 있는 '인덱스'로 점프를 해야한다.